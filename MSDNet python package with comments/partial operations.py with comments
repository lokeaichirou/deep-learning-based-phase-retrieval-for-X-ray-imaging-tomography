# The operations.py is dealing with intermediate images. Since the width is 1, i.e. growth rate is 1, 
# each hidden layer produces 1 newly generated intermediate image,i.e. feature map based on all collected intermediate images at this hidden layer itself.
# Each hidden layer has number of dilation filters which is equal to number of collected intermediate images at this hidden layer itself.  

\begin{lstlisting}

def relu(inp):
    lib.relu(asfloatp(inp.ravel()), aslong(inp.size))

def leakyrelu(inp, w):
    lib.leakyrelu(asfloatp(inp.ravel()), aslong(inp.size), asfloat(w))

def sum(inp):
    return lib.sum(asfloatp(inp.ravel()), aslong(inp.size))

def std(inp, mn):
    return lib.std(asfloatp(inp.ravel()), asfloat(mn), aslong(inp.size))

def multsum(a, b):
    return lib.multsum(asfloatp(a.ravel()), asfloatp(b.ravel()), aslong(a.size))

def softmax(inp):
    lib.softmax(asfloatp(inp.ravel()), aslong(inp[0].size), asuint(inp.shape[0]))

def squaresum(a):
    return lib.squaresum(asfloatp(a.ravel()),aslong(a.size))

def relu2(inp, out):
    lib.relu2(asfloatp(inp.ravel()), asfloatp(out.ravel()), aslong(inp.size))

def leakyrelu2(inp, out, w):
    lib.leakyrelu2(asfloatp(inp.ravel()), asfloatp(out.ravel()), aslong(inp.size), asfloat(w))

def combine(inp, out, w):
    lib.combine(asfloatp(inp.ravel()), asfloatp(out.ravel()), aslong(inp.size), asfloat(w))


def conv2d(inp, out, f, d):  # 2d dilation convolution filter was done here
    shx = indexlist(d, out.shape[0])
    shy = indexlist(d, out.shape[1])
    lib.conv2d(asfloatp(inp.ravel()), asfloatp(out.ravel()), asfloatp(f.ravel()), asuint(inp.shape[0]), asuint(inp.shape[1]), asintp(shx.ravel()), asintp(shy.ravel()))

def filtergradient2d(inp, delta, ux, uy):
    return lib.gradientmap2d(asfloatp(inp.ravel()), asfloatp(delta.ravel()), asuint(inp.shape[0]), asuint(inp.shape[1]), asintp(ux.ravel()), asintp(uy.ravel()))
    
# Actually these above defined functions perform the bottom level computation, thay use the ctypes python package.

# Internal data object for intermediate images (intermediate images contain input channels, hidden intermediate images,
# and output channels)
class ImageData(object):
    """Object that represents a set of 2D images on CPU.
    
    :param shape: total shape of all images
    :param dl: list of dilations in the network
    :param nin: number of input images of network
    """
    
    # ImageData object is a 3D numpy array that contains input channels and feature maps generated by all the hidden layers 


    def __init__(self, shape, dl, nin):
        self.arr = np.zeros(shape, dtype=np.float32)
        self.dl = dl
        self.nin = nin

    def setimages(self, ims):
        """Set data to set of images.
        
        :param ims: set of images
        """
        self.arr[:ims.shape[0]] = ims

    def setscalars(self, scl, start=0):
        """Set each image to a scalar.
        
        :param scl: scalar values
        """
        self.arr[start:] = scl

    def fill(self, val, start=None, end=None):
        """Set image data to single scalar value.
        
        :param val: scalar value
        """
        self.arr[start:end] = val

    def copy(self, start=None, end=None):
        """Return copy of image data."""
        return self.arr[start:end].copy()

    def get(self, start=None, end=None):
        """Return image data."""
        return self.arr[start:end]

    def add(self, val, i):
        """Add scalar to single image.
        
        :param val: scalar to add
        :param i: index of image to add value to
        """
        self.arr[i] += val

    def mult(self, val, i):
        """Multiply single image with value.
        
        :param val: value
        :param i: index of image to multiply
        """
        combine(self.arr[i], self.arr[i], val-1)

    def prepare_forw_conv(self, f):
        """Prepare for forward convolutions.
        
        :param f: convolution filters
        """
        self.forw_f = f

    def forw_conv(self, i, outidx, dl):
        """Perform forward convolutions
        
        :param i: image index to compute
        :param outidx: image index to write output to
        :param dl: dilation list
        """
        f = self.forw_f[i]
        for j in range(outidx):
            conv2d(self.arr[j], self.arr[outidx], f[j], dl)  # doing the 2d dilation convolution filtering with filter
            # f[j] over self.arr[j], add to the self.arr[outidx], doing it until self.arr[outdix-1].

    def prepare_back_conv(self, f):
        """Prepare for backward convolutions.
        
        :param f: convolution filters
        """
        self.back_f = f

    def back_conv(self, outidx, dl):
        """Perform backward convolutions
        
        :param outidx: image index to write output to
        :param dl: dilation list
        """
        f = self.back_f[outidx]
        for i in range(outidx+1, self.arr.shape[0]):
            conv2d(self.arr[i], self.arr[outidx], f[i-outidx-1], dl[i])  # doing the 2d dilation convolution filtering
            # with filter f[i-outidx-1] over self.arr[i], add to the self.arr[outidx], doing it until self.arr[0].

    @property
    def shape(self):
        return self.arr.shape

    def relu(self, i):
        """Apply ReLU to single image."""
        relu(self.arr[i])

    def relu2(self, i, dat, j):
        """Apply backpropagation ReLU to single image."""
        relu2(dat.arr[j], self.arr[i])

    def combine_all_all(self, dat, w):
        """Compute linear combinations of images."""
        # the final output channels are linear combination of all the collected intermediate images at the final hidden layer
        
        for i in range(self.arr.shape[0]):
            for j in range(dat.arr.shape[0]):
                combine(dat.arr[j], self.arr[i], w[i,j]) 
    
